import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = [
    "dateButton",
    "timeSlotContainer",
    "timeSlotList",
    "selectedSummary",
    "selectedDisplay",
    "placeholderSummary"
  ]

  static values = { timeSlots: Object }

  connect() {
    // Initialize time slots data from Rails
    this.initializeTimeSlots()

    // Restore complete state if both date and time are stored
    const dateField = this.getDeliveryDateField()
    const timeField = this.getDeliveryTimeField()

    if (dateField && timeField) {
      const selectedDate = dateField.value
      const selectedTime = timeField.value

      if (selectedDate) {
        // Restore date selection
        this.selectDateButton(selectedDate)
        this.showTimeSlots(selectedDate)

        // If time is also selected, restore complete state
        if (selectedTime) {
          this.restoreTimeSelection(selectedTime)
          this.showSelectedSummary()
          this.hidePlaceholderSummary()
        } else {
          this.showPlaceholderSummary()
        }
      } else {
        this.showPlaceholderSummary()
      }
    }
  }

  initializeTimeSlots() {
    // Time slots passed from the Rails component
    this.timeSlotsData = this.timeSlotsValue || {}
  }


  getDeliveryDateField() {
    return document.querySelector('input[name="checkout_form[delivery_date]"]')
  }

  getDeliveryTimeField() {
    return document.querySelector('input[name="checkout_form[delivery_time_slot]"]')
  }

  selectDate(event) {
    const selectedDate = event.currentTarget.dataset.date

    this.selectDateButton(selectedDate)
    this.showTimeSlots(selectedDate)

    // Update hidden field using robust selector
    const dateField = this.getDeliveryDateField()
    if (dateField) {
      dateField.value = selectedDate
    } else {
      return
    }

    // Clear previous time selection
    const timeField = this.getDeliveryTimeField()
    if (timeField) { timeField.value = "" }
    this.hideSelectedSummary()
    this.showPlaceholderSummary()
    this.persistSelection(selectedDate, null)
  }

  selectDateButton(dateString) {
    // Remove selected class from all date buttons
    this.dateButtonTargets.forEach(button => {
      button.classList.remove("selected")
    })

    // Add selected class to clicked button
    const selectedButton = this.dateButtonTargets.find(button =>
      button.dataset.date === dateString
    )
    if (selectedButton) {
      selectedButton.classList.add("selected")
    }
  }

  showTimeSlots(dateString) {
    // Generate time slots for the selected date
    const timeSlots = this.getTimeSlotsForDate(dateString)

    // Clear existing time slots
    this.timeSlotListTarget.innerHTML = ""

    // Create time slot buttons
    timeSlots.forEach(slot => {
      const button = this.createTimeSlotButton(slot)
      this.timeSlotListTarget.appendChild(button)
    })

    this.timeSlotContainerTarget.style.display = "block"
  }

  getTimeSlotsForDate(dateString) {
    // Use time slots generated by Rails component
    return this.timeSlotsData[dateString] || []
  }

  createTimeSlotButton(slot) {
    const button = document.createElement("button")
    button.type = "button"
    button.className = `time-button flex-shrink-0 ${slot.disabled ? "disabled" : ""}`
    button.textContent = slot.display
    button.dataset.timeSlot = slot.time
    button.disabled = slot.disabled
    button.setAttribute('aria-label', `Select ${slot.display} time slot for delivery`)

    if (!slot.disabled) {
      button.addEventListener("click", (e) => this.selectTimeSlot(e))
    }

    return button
  }

  selectTimeSlot(event) {
    const timeSlot = event.currentTarget.dataset.timeSlot

    this.timeSlotListTarget.querySelectorAll(".time-button").forEach(button => {
      button.classList.remove("selected")
    })

    event.currentTarget.classList.add("selected")

    // Update hidden field using robust selector
    const timeField = this.getDeliveryTimeField()
    if (timeField) {
      timeField.value = timeSlot
    } else {
      return
    }

    this.showSelectedSummary()
    this.hidePlaceholderSummary()

    // Announce selection to screen readers
    this.announceTimeSelection(timeSlot)

    const dateField = this.getDeliveryDateField()
    const selectedDate = dateField ? dateField.value : null
    this.persistSelection(selectedDate, timeSlot)
  }

  restoreTimeSelection(timeSlot) {
    // Wait briefly for time buttons to be created by showTimeSlots()
    setTimeout(() => {
      const timeButtons = this.timeSlotListTarget.querySelectorAll('.time-button')
      timeButtons.forEach(button => {
        button.classList.remove('selected')
        if (button.dataset.timeSlot === timeSlot) {
          button.classList.add('selected')
        }
      })
    }, 50)
  }

  showSelectedSummary() {
    const dateField = this.getDeliveryDateField()
    const timeField = this.getDeliveryTimeField()

    if (!dateField || !timeField) return

    const selectedDate = dateField.value
    const selectedTime = timeField.value

    if (selectedDate && selectedTime && this.hasSelectedDisplayTarget && this.hasSelectedSummaryTarget) {
      const displayText = this.formatSelectedSchedule(selectedDate, selectedTime)
      this.selectedDisplayTarget.textContent = displayText
      this.selectedSummaryTarget.classList.remove("hidden")
    }
  }

  hideSelectedSummary() {
    if (this.hasSelectedSummaryTarget) {
      this.selectedSummaryTarget.classList.add("hidden")
    }
  }

  showPlaceholderSummary() {
    if (this.hasPlaceholderSummaryTarget) {
      this.placeholderSummaryTarget.classList.remove("hidden")
    }
  }

  hidePlaceholderSummary() {
    if (this.hasPlaceholderSummaryTarget) {
      this.placeholderSummaryTarget.classList.add("hidden")
    }
  }

  announceTimeSelection(timeSlot) {
    // Create a temporary element for screen reader announcement
    const announcement = document.createElement('div')
    announcement.setAttribute('aria-live', 'polite')
    announcement.setAttribute('aria-atomic', 'true')
    announcement.style.position = 'absolute'
    announcement.style.left = '-10000px'
    announcement.textContent = `Time slot ${timeSlot} selected for delivery`

    document.body.appendChild(announcement)

    // Remove the announcement after a short delay
    setTimeout(() => {
      if (announcement.parentNode) {
        announcement.parentNode.removeChild(announcement)
      }
    }, 1000)
  }

  formatSelectedSchedule(dateString, timeSlot) {
    const date = new Date(dateString)
    const today = new Date()
    const tomorrow = new Date(today)
    tomorrow.setDate(tomorrow.getDate() + 1)

    let dateDisplay
    if (date.toDateString() === today.toDateString()) {
      dateDisplay = "Today"
    } else if (date.toDateString() === tomorrow.toDateString()) {
      dateDisplay = "Tomorrow"
    } else {
      dateDisplay = date.toLocaleDateString("en-US", {
        weekday: "long",
        month: "short",
        day: "numeric"
      })
    }

    // Find the formatted 24-hour display for this time slot
    const timeSlotsForDate = this.timeSlotsData[dateString] || []
    const selectedSlot = timeSlotsForDate.find(slot => slot.time === timeSlot)
    const timeDisplay = selectedSlot ? selectedSlot.display : timeSlot

    return `${dateDisplay} - ${timeDisplay}`
  }

  persistSelection(selectedDate, selectedTimeSlot) {
    // Send a request to persist the date/time selection
    const formData = new FormData()

    if (selectedDate) {
      formData.append('checkout_form[delivery_date]', selectedDate)
    }

    if (selectedTimeSlot) {
      formData.append('checkout_form[delivery_time_slot]', selectedTimeSlot)
    }

    fetch('/checkout', {
      method: 'PATCH',
      headers: {
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content,
        'Accept': 'application/json'
      },
      body: formData
    }).catch(error => {
      console.error('Error persisting delivery schedule:', error)
    })
  }
}
